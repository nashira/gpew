<!DOCTYPE html>
<html lang='en'>
<head>
  <title>webgl</title>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0'>
  <style>
  body {
    background-color: #000000;
    margin: 0px;
    overflow: hidden;
    font-family:Monospace;
    font-size:13px;
    text-align:center;
    font-weight: bold;
    text-align:center;
  }
  canvas {}

  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script src='../lib/stats.min.js'></script>
  <script src='../../src/program.js'></script>
  <script src='../../src/databuffer.js'></script>
  <script src='../../src/indexbuffer.js'></script>
  <script src='../../src/rendertarget.js'></script>
  <script src='../../src/texture.js'></script>
  <script src='../../src/utils.js'></script>
  <script src='../../src/shaderlib.js'></script>
  <script src='terrain_program.js'></script>

  <script>
  	var stats = new Stats();
  	stats.domElement.style.position = 'absolute';
  	stats.domElement.style.left = '0px';
  	stats.domElement.style.top = '0px';
  	document.body.appendChild(stats.domElement);
    var canvas = document.getElementById('canvas');
    var devicePixelRatio = window.devicePixelRatio || 1;
    var width = window.innerWidth;
    var height = window.innerHeight;
    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;
    canvas.style.width = canvas.style.height = '100%';
    var gl = canvas.getContext('experimental-webgl');
    Program.init(gl);
    TerrainGenerator.init(gl);

    var vertexShader = [
      'precision highp float;',
      'uniform mat4 mvMatrix;',
      'uniform mat4 pMatrix;',
      'uniform sampler2D position;',
      'attribute vec2 coords;',

      'varying vec3 vPosition;',
      'varying vec3 vWorldPos;',
      'varying vec3 vNormal;',
      
      'void main() {',
      '  vec4 vertex = texture2D(position, coords);',
      '  vec3 pos = vec3(coords.x - .5, vertex.a, coords.y - .5);',
      '  vec4 wPos = mvMatrix * vec4(pos, 1.);',
      '  vPosition = pos;',
      '  vWorldPos = wPos.xyz;',
      '  vNormal = vertex.xyz;',
      '  gl_Position = pMatrix * wPos;',
      '}'
      ].join('\n');
    
    
    var fragmentShader = [
      'precision highp float;',
      'uniform float time;',
      'uniform mat4 mvMatrix;',
      
      'varying vec3 vWorldPos;',
      'varying vec3 vPosition;',
      'varying vec3 vNormal;',

      // 'const vec3 light_direction = vec3(0.24, -0.97, 0.);',
      'const vec3 light_direction = vec3(0.0, -1., 0.);',
      // 'const vec4 light_diffuse = vec4(0.8, 0.8, 0.8, 0.0);',
      'const vec4 light_diffuse = vec4(1., 1., 1., 0.0);',
      'const vec4 light_ambient = vec4(0.2, 0.2, 0.3, 1.0);',
      'const vec4 light_specular = vec4(1.0, 1.0, 1.0, 1.0);',
      
      'void main() {',
      // '  gl_FragColor = vec4(.4,.25,.15, 1.);',
      // '  gl_FragColor = vec4(vColor, 1.);',
      '  gl_FragColor = vec4(vNormal, 1.);',
      
      'vec3 mv_light_direction = normalize((mvMatrix * vec4(light_direction, 0.0)).xyz);',
      'vec3 eye = normalize(vWorldPos);',
      'vec3 reflection = reflect(mv_light_direction, vNormal);',
      // 'vec4 frag_diffuse = vec4(.1);',
      
      'vec4 frag_diffuse = vec4(mix(vec3(.4,.25,.15), vec3(1.), vPosition.y * 30.), 1.);',
      'vec4 diffuse_factor = max(-dot(vNormal, mv_light_direction), 0.0) * light_diffuse;',
      'vec4 ambient_diffuse_factor = diffuse_factor + light_ambient;',
      'vec4 specular_factor = max(pow(-dot(reflection, eye), vNormal.y * vNormal.y), 0.0) * light_specular;',
      'gl_FragColor = specular_factor * vec4(.1) + ambient_diffuse_factor * frag_diffuse;',
      
      // 'gl_FragColor = ambient_diffuse_factor * frag_diffuse;',
      
      '}'
      ].join('\n');

    
    var w = 512, h = 512;
    var terrainGen = new TerrainGenerator(w, h);
    var program = new Program(vertexShader, fragmentShader, {drawMode: gl.TRIANGLE_STRIP, cullFace: gl.BACK});
    // var program = new Program(vertexShader, fragmentShader, {drawMode: gl.LINE_STRIP});
    
    buildGeo(w, h);
    var num = (2 * w) * (h - 1) + 3 * (h - 1);
    
    program.addUniform('position', 't', terrainGen.renderTarget.getGlTexture())
    program.addUniform('time', 'f', 0);
    program.setViewport(0, 0, width * 2, height * 2);

    var rm = Matrix.makeYRotation(0);
    var sm = Matrix.makeScale(2,2,2);
    var tm = Matrix.makeLookAt([0, 1, 3], [0, 0, 0], [0, 1, 0]);
    // var tm = Matrix.makeLookAt([0, 8, 20], [0, 0, 0], [0, 1, 0]);
    var pm = Matrix.makePerspective(.8, width / height, .1, 1000);
    var matrix = [];
    
    program.addUniform('pMatrix', 'm4', pm);
    program.addUniform('mvMatrix', 'm4', tm);

    var time = 0, count = 0;
    function animate() {
      time += 0.0005;
      count++;
      program.setUniform('time', time/100);

      Matrix.setYRotation(rm, time);
      Matrix.multiply(matrix, sm, rm, tm);
      program.setUniform('mvMatrix', matrix);
      
      if (count % 2 == 0) {
        // terrainGen.erosionProgram.step();
        terrainGen.applyErosion();
        program.setUniform('position', terrainGen.renderTarget.getGlTexture());
      }
      program.draw(0, num);
      
      // requestAnimationFrame(animate);
      stats.update();
    }
    

    terrainGen.generate();
    terrainGen.erosionProgram.setUniform('terrain', terrainGen.renderTarget.getGlTexture());
    terrainGen.erosionProgram.setRenderTarget(null);
    terrainGen.erosionProgram.draw(0,4);
    
    // terrainGen.erosionProgram.step();
    // animate();
    
    function buildGeo(w, h) {
      var w1 = w - 1;
      var h1 = h - 1;
      // var w1h1 = w1 * h1;
      var i, j, y, y1, d = true;
      var numVerts = w * h;
      var vertecies = [];
      var indecies = [];
      var sx = 1 / w ;
      var sy = 1 / h;
      // var sy = 0;
      // var sx = 0;
      
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          var x = sx * j + sx * 0.5;
          var y = sy * i + sy * 0.5;
          // var l = Math.sqrt(2 * Math.max(x * x, y * y));
          // var l = Math.sqrt(x * x + y * y);
          // l = Math.exp(l*.001);
          // vertecies.push(x * l, y * l);
          vertecies.push(x, y);
        }
      }

      for (i = 0; i < h1; i++) {
        y = i * w;
        y1 = y + w;
        if (d) {
          for (j = 0; j < w; j++) {
            indecies.push(y+j, y1+j);
          }
          indecies.push(y1+w1, y1+w1, y1+w1);
        } else {
          for (j = w1; j >= 0; j--) {
            indecies.push(y+j, y1+j);
          }
          indecies.push(y1, y1, y1);
        }
        d = !d;
      }
      //     var id = w1h1 + (i * w + j);
      // indecies.push(id+0,id+1,id+2,id+0,id+2,id+3,id+0,id+3,id+4,id+0,id+4,id+1);
      // [.5,.5,0,0,1,0,1,1,0,1]
      // [0,1,2,0,2,3,0,3,4,0,4,1]
      // console.log(numVerts)
      // console.log(vertecies)
      // console.log(indecies)
      // var ca = []; for(var i = 0; i < numVerts*3; i++) ca.push(Math.random());
      // var color = new DataBuffer(3, numVerts, new Float32Array(ca));
      // program.addAttribute('color', 3, gl.FLOAT, color);
      
      var position = new DataBuffer(2, numVerts, new Float32Array(vertecies));
      program.addAttribute('coords', 2, gl.FLOAT, position);
      var indecies = new IndexBuffer(4, num, new Uint32Array(indecies), gl.UNSIGNED_INT);
      program.setIndexBuffer(indecies);
    }
  </script>

</body>
</html>
